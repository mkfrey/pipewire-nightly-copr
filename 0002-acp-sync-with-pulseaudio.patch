From cd4a47666d537fce00e736dde5a0170f93260f10 Mon Sep 17 00:00:00 2001
From: Wim Taymans <wtaymans@redhat.com>
Date: Thu, 22 Apr 2021 12:25:48 +0200
Subject: [PATCH 02/10] acp: sync with pulseaudio

Remove our custom hack to work around missing duplex and use
upstream fix.
---
 spa/plugins/alsa/acp/alsa-mixer.c | 24 +++++++++++++++++-------
 spa/plugins/alsa/acp/idxset.h     |  8 ++++++++
 2 files changed, 25 insertions(+), 7 deletions(-)

diff --git a/spa/plugins/alsa/acp/alsa-mixer.c b/spa/plugins/alsa/acp/alsa-mixer.c
index 606d00b8..9d41b193 100644
--- a/spa/plugins/alsa/acp/alsa-mixer.c
+++ b/spa/plugins/alsa/acp/alsa-mixer.c
@@ -5142,6 +5142,7 @@ void pa_alsa_profile_set_probe(
     pa_alsa_profile **pp, **probe_order;
     pa_alsa_mapping *m;
     pa_hashmap *broken_inputs, *broken_outputs, *used_paths;
+    pa_alsa_mapping *selected_fallback_input = NULL, *selected_fallback_output = NULL;
 
     pa_assert(ps);
     pa_assert(dev_id);
@@ -5164,13 +5165,16 @@ void pa_alsa_profile_set_probe(
         uint32_t idx;
         p = *pp;
 
-        pa_log_debug("Check Profile %s.", p->name);
-
-        /* Skip if fallback and already found something */
+        /* Skip if fallback and already found something, but still probe already selected fallbacks.
+         * If UCM is used then both fallback_input and fallback_output flags are false.
+         * If UCM is not used then there will be only a single entry in mappings.
+         */
         if (found_input && p->fallback_input)
-            continue;
+            if (selected_fallback_input == NULL || pa_idxset_get_by_index(p->input_mappings, 0) != selected_fallback_input)
+                continue;
         if (found_output && p->fallback_output)
-            continue;
+            if (selected_fallback_output == NULL || pa_idxset_get_by_index(p->output_mappings, 0) != selected_fallback_output)
+                continue;
 
         /* Skip if this is already marked that it is supported (i.e. from the config file) */
         if (!p->supported) {
@@ -5261,14 +5265,20 @@ void pa_alsa_profile_set_probe(
         if (p->output_mappings)
             PA_IDXSET_FOREACH(m, p->output_mappings, idx)
                 if (m->output_pcm) {
-                    found_output |= !p->fallback_output;
+                    found_output = true;
+                    if (p->fallback_output && selected_fallback_output == NULL) {
+                        selected_fallback_output = m;
+                    }
                     mapping_paths_probe(m, p, PA_ALSA_DIRECTION_OUTPUT, used_paths, mixers);
                 }
 
         if (p->input_mappings)
             PA_IDXSET_FOREACH(m, p->input_mappings, idx)
                 if (m->input_pcm) {
-                    found_input |= !p->fallback_input;
+                    found_input = true;
+                    if (p->fallback_input && selected_fallback_input == NULL) {
+                        selected_fallback_input = m;
+                    }
                     mapping_paths_probe(m, p, PA_ALSA_DIRECTION_INPUT, used_paths, mixers);
                 }
     }
diff --git a/spa/plugins/alsa/acp/idxset.h b/spa/plugins/alsa/acp/idxset.h
index 4840f0fc..6e88a847 100644
--- a/spa/plugins/alsa/acp/idxset.h
+++ b/spa/plugins/alsa/acp/idxset.h
@@ -181,6 +181,14 @@ static inline void* pa_idxset_get_by_data(pa_idxset*s, const void *p, uint32_t *
 	return item->ptr;
 }
 
+static inline void* pa_idxset_get_by_index(pa_idxset*s, uint32_t idx)
+{
+        pa_idxset_item *item;
+	if (!pa_array_check_index(&s->array, idx, pa_idxset_item))
+		return NULL;
+	item = pa_array_get_unchecked(&s->array, idx, pa_idxset_item);
+	return item->ptr;
+}
 
 #define PA_IDXSET_FOREACH(e, s, idx) \
 	for ((e) = pa_idxset_first((s), &(idx)); (e); (e) = pa_idxset_next((s), &(idx)))
-- 
2.30.2

